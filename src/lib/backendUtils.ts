import fs from "fs/promises";
import tmp from "os";
import { exec } from "child_process";
import path from "path";

/**
 * Converts a single EPUB File object to KEPUB using kepubify CLI.
 * @param file File object representing the EPUB file.
 * @returns Promise that resolves to the output KEPUB File object.
 */
export async function epubToKepub(file: File): Promise<File> {
  // First we write the input file to a temporary location
  // this is necessary because kepubify CLI requires a file path.
  // We add a salt to the temp file name to avoid conflicts
  const salt = Math.random().toString(36).substring(2, 15);
  const tempDir = tmp.tmpdir();
  const tempFolder = path.join(tempDir, salt);
  await fs.mkdir(tempFolder, { recursive: true }); // Ensure directory exists
  const tempInputPath = path.join(tempFolder, file.name);
  await fs.writeFile(tempInputPath, Buffer.from(await file.arrayBuffer()));

  // Similarly, kepubify CLI requires an output file path so we need to prepare that
  const outputFileName = file.name.replace(/\.epub$/i, "_converted.kepub.epub");
  const tempOutputPath = path.join(tempFolder, outputFileName);
  const kebupifyPath = process.env.KEPUBIFYPATH;

  // Now we can call the CLI command to convert the file
  await new Promise<void>((resolve, reject) => {
    exec(`"${kebupifyPath}" "${tempInputPath}" -o "${tempFolder}"`, (error) => {
      if (error) reject(error);
      else resolve();
    });
  });

  // Now we can read the output file generated by kepubify back into a File object
  const outputBuffer = await fs.readFile(tempOutputPath);
  const kepubFile = new File([outputBuffer], outputFileName, {
    type: "application/octet-stream",
  });

  // We don't need the temporary files anymore, so we can delete them
  await fs.unlink(tempInputPath);
  await fs.unlink(tempOutputPath);

  return kepubFile;
}

import crypto from "crypto";

/**
 * Computes a unique file name based on the file's content.
 * @param file File object for which to generate name
 * @returns Promise that resolves to the generated filename
 */
export async function generateUniqueIdentifier(file: File): Promise<string> {
  const contentBuffer = Buffer.from(await file.arrayBuffer());
  const hash = crypto
    .createHash("sha256")
    .update(contentBuffer)
    .digest("hex")
    .slice(0, 12); // 12 chars is probably enough to avoid collisions, as it allows for 2^96 different values

  return hash;
}

const folderPath = path.join(process.cwd(), "storage", "books");

/**
 * Writes a Kepub file to the storage/books folder.
 * @param file File object representing the KEPUB file.
 * @param uniqueID A unique identifier for the file which is used to create a unique subdirectory.
 */
export async function writeKepubFile(
  file: File,
  uniqueID: string,
): Promise<void> {
  const dirPath = path.join(folderPath, uniqueID);
  await fs.mkdir(dirPath, { recursive: true }); // Ensure subdirectory exists

  const filePath = path.join(dirPath, "book.epub");

  try {
    await fs.access(filePath);
    console.warn(
      `Warning: File with ID ${uniqueID} already exists, aborting write to it`,
    );
  } catch (err) {
    // File does not exist, so we can make it
    await fs.writeFile(filePath, Buffer.from(await file.arrayBuffer()));
  }
}

import EPub from "epub";

interface EpubData {
  metadata: any;
  manifest: any;
}

/**
 * Extracts metadata and manifest from a KEPUB file.
 * @param bookID Name of the directory where the KEPUB file is stored.
 * @returns Promise that resolves to an object containing metadata and manifest.
 */
export async function extractMetadata(bookID: string): Promise<EpubData> {
  const epub = new EPub(path.join(folderPath, bookID, "book.epub"));

  return new Promise((resolve, reject) => {
    epub.on("end", () => {
      resolve({
        metadata: epub.metadata,
        manifest: epub.manifest,
      });
    });
    epub.on("error", reject);
    epub.parse();
  });
}

import AdmZip from "adm-zip";

/**
 * Extracts cover image from a KEPUB file.
 * @param data EpubData object containing metadata and manifest.
 * @param bookID Name of the directory where the KEPUB file is stored.
 * @returns Promise that resolves to an object referencing the cover image file or an Error if no cover image is found.
 */
export async function extractCoverImage(
  data: EpubData,
  bookID: string,
): Promise<string | Error> {
  // The metadata has a cover property, which is not the name of the cover file but id of an item in the manifest of the metadata file
  // The item with that id then contains the name of the cover file
  // For example, if the metadata.cover is "cover-image", there might be something like this in the manifest:
  // <item id="cover-image" properties="cover-image" href="bookcover-generated.jpg" media-type="image/jpeg"/>\
  const metadata: any = data.metadata;
  const manifest = data.manifest;
  const coverItemName = metadata.cover || "cover-image"; // This would be "cover-image" in the example above
  const imageFilePath = manifest[coverItemName]?.href; // This is the name of the cover file in the manifest

  if (!imageFilePath) {
    return new Error(`No cover image found`);
  }

  const bookFolderPath = path.join(folderPath, bookID);
  const bookFilePath = path.join(bookFolderPath, "book.epub");

  const zip = new AdmZip(bookFilePath);
  const imageEntry = zip.getEntry(imageFilePath);
  if (!imageEntry) {
    throw new Error(`Cover image "${imageFilePath}" not found in archive`);
  }
  const fileExtension = path.extname(imageFilePath);
  const outputPath = path.join(bookFolderPath, `cover${fileExtension}`);
  await fs.writeFile(outputPath, imageEntry.getData());

  return fileExtension;
}
