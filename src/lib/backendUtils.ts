import fs from "fs/promises";
import tmp from "os";
import { exec } from "child_process";
import path from "path";

/**
 * Converts a single EPUB File object to KEPUB using kepubify CLI.
 * @param file File object representing the EPUB file.
 * @returns Promise that resolves to the output KEPUB File object.
 */
export async function epubToKepub(file: File): Promise<File> {
  // First we write the input file to a temporary location
  // this is necessary because kepubify CLI requires a file path.
  // We add a salt to the temp file name to avoid conflicts
  const salt = Math.random().toString(36).substring(2, 15);
  const tempDir = tmp.tmpdir();
  const tempFolder = path.join(tempDir, salt);
  await fs.mkdir(tempFolder, { recursive: true }); // Ensure directory exists
  const tempInputPath = path.join(tempFolder, file.name);
  await fs.writeFile(tempInputPath, Buffer.from(await file.arrayBuffer()));

  // Similarly, kepubify CLI requires an output file path so we need to prepare that
  const outputFileName = file.name.replace(/\.epub$/i, "_converted.kepub.epub");  
  const tempOutputPath = path.join(tempFolder, outputFileName);
  const kebupifyPath = process.env.KEPUBIFYPATH

  // Now we can call the CLI command to convert the file
  await new Promise<void>((resolve, reject) => {
    exec(`"${kebupifyPath}" "${tempInputPath}" -o "${tempFolder}"`, (error) => {
      if (error) reject(error);
      else resolve();
      });
  });

  // Now we can read the output file generated by kepubify back into a File object
  const outputBuffer = await fs.readFile(tempOutputPath);
  const kepubFile = new File([outputBuffer], outputFileName, { type: "application/octet-stream" });

  // We don't need the temporary files anymore, so we can delete them
  await fs.unlink(tempInputPath);
  await fs.unlink(tempOutputPath);

  return kepubFile;
}


import crypto from "crypto";

/**
 * Computes a unique file name based on the file's content.
 * @param file File object for which to generate name
 * @returns Promise that resolves to the generated filename
 */
export async function generateUniqueFileName(file: File): Promise<string> {
  const contentBuffer = Buffer.from(await file.arrayBuffer());
  const hash = crypto.createHash("sha256").update(contentBuffer).digest("hex").slice(0, 12); // 12 chars is probably enough to avoid collisions, as it allows for 2^96 different values
  
  const extension = path.extname(file.name);
  const fileName = `${hash}${extension}`;

  return fileName;
}


const folderPath = path.join(process.cwd(), "public", "books");

/**
 * Writes a Kepub file to the public/books folder.
 * @param file File object representing the KEPUB file.
 * @returns Promise that resolves to the file path where the KEPUB file was written.
 */
export async function writeKepubFile(file: File): Promise<string> {
  await fs.mkdir(folderPath, { recursive: true }); // Ensure directory exists

  const fileName = await generateUniqueFileName(file);
  const filePath = path.join(folderPath, fileName);

  try {
    await fs.access(filePath);
    console.warn(`Warning: File already exists and will be overwritten: ${fileName}`);
  } catch (err) {
    // File does not exist, all is well
  }

  await fs.writeFile(filePath, Buffer.from(await file.arrayBuffer()));

  return fileName;
}

import  EPub  from 'epub';
/**
 * Extracts metadata from a KEPUB file.
 * @param filename filename of the KEPUB file to extract metadata from.
 * @returns Promise that resolves to an object containing the metadata.
 */
export async function extractMetadata(filename: string): Promise<EPub.Metadata> {
  const epub = new EPub(path.join(folderPath, filename));

  return new Promise((resolve, reject) => {
    epub.on('end', () => {
      resolve(epub.metadata);
    });
    epub.on('error', reject);
    epub.parse();
  });
}
